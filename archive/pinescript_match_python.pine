//@version=5
indicator("VCP & HTF & Cup (Match Python)", overlay = true, max_labels_count = 500)

// ═══════════════════════════════════════════════════════════════
// 1. 參數設置
// ═══════════════════════════════════════════════════════════════
patternMode = input.string("All", "Pattern mode", options = ["VCP", "HTF", "Cup", "VCP+HTF", "VCP+Cup", "HTF+Cup", "All"], group="General")
showVCP = patternMode == "VCP" or patternMode == "VCP+HTF" or patternMode == "VCP+Cup" or patternMode == "All"
showHTF = patternMode == "HTF" or patternMode == "VCP+HTF" or patternMode == "HTF+Cup" or patternMode == "All"
showCup = patternMode == "Cup" or patternMode == "VCP+Cup" or patternMode == "HTF+Cup" or patternMode == "All"

// --- 通用窗口（模擬Python的WINDOW_DAYS） ---
windowDays = input.int(126, "Window Days (for HTF & Cup)", minval = 40, maxval = 200, group="General")

// --- EMA ---
ema50_len = 50
ema150_len = 150
ema200_len = 200
lookback52 = input.int(252, "52-week lookback", minval = 20, group="General")

ema50 = ta.sma(close, ema50_len)
ema150 = ta.sma(close, ema150_len)
ema200 = ta.sma(close, ema200_len)
high52 = ta.highest(high, lookback52)
low52 = ta.lowest(low, lookback52)

// --- Cup 參數 ---
grpCup = "Cup with Handle"
cupMinDepth = input.float(12.0, "Min Depth (%)", minval = 5.0, group=grpCup)
cupMaxDepth = input.float(33.0, "Max Depth (%)", minval = 10.0, group=grpCup)
handleMaxDepth = input.float(15.0, "Handle Max Depth (%)", minval = 5.0, group=grpCup)
handleMinLen = input.int(5, "Handle Min Length", minval = 3, group=grpCup)

// --- HTF 參數（對應Python預設值） ---
grpHTF = "High Tight Flag"
htfMinRunUp = input.float(60.0, "Min Run-Up (%)", minval = 10.0, group=grpHTF, tooltip="Python預設60%")
htfMaxPullback = input.float(25.0, "Max Pullback (%)", minval = 5.0, group=grpHTF)
htfMinFlagDays = input.int(3, "Min Flag Days", minval = 2, group=grpHTF)
htfMaxFlagDays = input.int(12, "Max Flag Days", minval = 5, group=grpHTF, tooltip="Python預設12")

// --- VCP 參數 ---
grpVCP = "VCP"
vcp_left = input.int(3, "Pivot Left", minval = 1, group=grpVCP)
vcp_right = input.int(3, "Pivot Right", minval = 1, group=grpVCP)
vcpMinDepth = input.float(3.0, "Min Contraction (%)", minval = 0.1, group=grpVCP)

// ═══════════════════════════════════════════════════════════════
// 2. 趨勢過濾
// ═══════════════════════════════════════════════════════════════
trendUp = close > ema50 and ema50 > ema150 and ema150 > ema200
aboveLow52 = high52 > 0 and close > low52 * 1.25 

// ═══════════════════════════════════════════════════════════════
// 3. CUP WITH HANDLE（完全對應Python）
// ═══════════════════════════════════════════════════════════════
f_detectCup() =>
    bool found = false
    float buyPrice = na
    float stopPrice = na
    
    if bar_index >= windowDays and trendUp and aboveLow52
        int n = windowDays
        
        // 步驟1: 找左高點（前50%的high）
        int halfPoint = int(n / 2)
        float leftHighPrice = high[halfPoint]
        int leftHighIdx = halfPoint
        
        for i = n - 1 to halfPoint
            if high[i] > leftHighPrice
                leftHighPrice := high[i]
                leftHighIdx := i
        
        // 步驟2: 找杯底（從左高點到75%位置的close）
        // ✅ 修正：正確計算搜尋範圍
        int endOfBottomSearch = n - int(n * 0.75)
        
        if leftHighIdx > endOfBottomSearch 
            float bottomPrice = close[leftHighIdx]
            int bottomIdx = leftHighIdx
            
            for i = leftHighIdx - 1 to endOfBottomSearch
                if close[i] < bottomPrice
                    bottomPrice := close[i]
                    bottomIdx := i
            
            // 深度檢查（轉為百分比）
            float depth = leftHighPrice > 0 ? (1.0 - bottomPrice / leftHighPrice) * 100.0 : 0.0
            
            if depth >= cupMinDepth and depth <= cupMaxDepth
                // 步驟3: 找右高點（從底部到當前的close）
                float rightHigh = close[bottomIdx]
                for i = bottomIdx - 1 to 0
                    if close[i] > rightHigh
                        rightHigh := close[i]
                
                // 檢查：從底部到當前至少10根（對應Python的len(right) >= 10）
                if bottomIdx >= 10
                    // 步驟4: Handle分析（最近20%）
                    int handleLen = math.max(int(n * 0.2), handleMinLen)
                    
                    if handleLen <= bottomIdx
                        float handleHigh = high[0]
                        float handleLow = low[0]
                        float handleVolSum = 0.0
                        
                        for i = 0 to handleLen - 1
                            if high[i] > handleHigh
                                handleHigh := high[i]
                            if low[i] < handleLow
                                handleLow := low[i]
                            handleVolSum += volume[i]
                        
                        float handleVolAvg = handleVolSum / handleLen
                        float windowVolSum = 0.0
                        for i = 0 to n - 1
                            windowVolSum += volume[i]
                        float windowVolAvg = windowVolSum / n
                        
                        // Handle驗證
                        float cupRange = rightHigh - bottomPrice
                        float minHandleLow = bottomPrice + 0.5 * cupRange
                        
                        bool positionOk = handleLow >= minHandleLow 
                        bool volOk = handleVolAvg < windowVolAvg    
                        bool validShape = handleLow < handleHigh    
                        float handleDepthPct = handleHigh > 0 ? (handleHigh - handleLow) / handleHigh * 100.0 : 100.0
                        bool depthOk = handleDepthPct <= handleMaxDepth

                        if positionOk and volOk and validShape and depthOk
                            found := true
                            buyPrice := handleHigh
                            stopPrice := handleLow
    [found, buyPrice, stopPrice]

var bool cupActive = false
var float cupBuy = na
var float cupStop = na
var int cupStartIdx = na
var bool cupBreakout = false
cupBreakout := false 

if showCup and not cupActive
    [isCup, bp, sp] = f_detectCup()
    if isCup
        cupActive := true
        cupBuy := bp
        cupStop := sp
        cupStartIdx := bar_index
        label.new(bar_index, low, "Cup\nB:" + str.tostring(bp, "#.##"), 
                  style=label.style_label_up, color=color.blue, textcolor=color.white, size=size.small)

if cupActive
    if low < cupStop or (bar_index - cupStartIdx > 30)
        cupActive := false
        cupBuy := na
        cupStop := na
    else if close > cupBuy
        cupBreakout := true
        cupActive := false 
        cupBuy := na

plot(showCup and cupActive ? cupBuy : na, "Cup Buy", color=color.blue, style=plot.style_linebr, linewidth=2)
plot(showCup and cupActive ? cupStop : na, "Cup Stop", color=color.new(color.blue, 50), style=plot.style_linebr)
plotshape(showCup and cupBreakout, "Cup Break", shape.triangleup, location.belowbar, color.blue, size=size.small, text="Cup")

// ═══════════════════════════════════════════════════════════════
// 4. HIGH TIGHT FLAG（完全重寫，對應Python）
// ═══════════════════════════════════════════════════════════════
f_detectHTF() =>
    bool found = false
    float buyPrice = na
    float stopPrice = na
    string grade = "C"
    
    if bar_index >= windowDays and trendUp
        int n = windowDays
        
        // ✅ 修正1: 在整個窗口中找pole高點（不是固定20根）
        float maxPrice = high[0]
        int maxIdx = 0
        for i = 0 to n - 1
            if high[i] > maxPrice
                maxPrice := high[i]
                maxIdx := i
        
        // ✅ 修正2: 起始價是窗口開始（不是固定60根前）
        float startPrice = close[n - 1]
        
        if startPrice > 0
            // ✅ 修正3: Run-up計算（預設60%）
            float runUpPct = (maxPrice / startPrice - 1.0) * 100.0
            
            if runUpPct >= htfMinRunUp
                // Flag: 從pole之後到當前
                int flagLen = maxIdx
                
                // ✅ 修正4: Flag長度檢查（3-12根）
                if flagLen >= htfMinFlagDays and flagLen <= htfMaxFlagDays
                    // 計算Flag的高低點
                    float flagHigh = high[0]
                    float flagLow = low[0]
                    float flagVolSum = 0.0
                    
                    for i = 0 to maxIdx - 1
                        if high[i] > flagHigh
                            flagHigh := high[i]
                        if low[i] < flagLow
                            flagLow := low[i]
                        flagVolSum += volume[i]
                    
                    // Pullback檢查
                    float pullbackPct = maxPrice > 0 ? (1.0 - flagLow / maxPrice) * 100.0 : 100.0
                    
                    if pullbackPct <= htfMaxPullback
                        // ✅ 修正5: Pole成交量 = 從開始到pole（不是固定11根）
                        float poleVolSum = 0.0
                        for i = maxIdx to n - 1
                            poleVolSum += volume[i]
                        
                        float flagVolAvg = flagLen > 0 ? flagVolSum / flagLen : 0.0
                        float poleVolAvg = (n - maxIdx) > 0 ? poleVolSum / (n - maxIdx) : 0.0
                        
                        // 成交量萎縮檢查
                        if flagVolAvg < poleVolAvg and poleVolAvg > 0
                            // 計算Grade（對應Python的分級系統）
                            float volDrop = 1.0 - flagVolAvg / poleVolAvg
                            grade := "C"
                            
                            if runUpPct > 90.0
                                if pullbackPct < 15.0 and volDrop > 0.50
                                    grade := "A"
                                else if pullbackPct < 20.0
                                    grade := "B"
                            
                            // 驗證buy > stop
                            if flagLow < flagHigh
                                found := true
                                buyPrice := flagHigh
                                stopPrice := flagLow
    
    [found, buyPrice, stopPrice, grade]

var bool htfActive = false
var float htfBuy = na
var float htfStop = na
var string htfGrade = "C"
var int htfStartIdx = na
var bool htfBreakout = false
htfBreakout := false

if showHTF and not htfActive
    [isHTF, bp, sp, g] = f_detectHTF()
    if isHTF
        htfActive := true
        htfBuy := bp
        htfStop := sp
        htfGrade := g
        htfStartIdx := bar_index
        label.new(bar_index, high, "HTF " + g, 
                  style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)

if htfActive
    if low < htfStop or (bar_index - htfStartIdx > htfMaxFlagDays + 5)
        htfActive := false
        htfBuy := na
        htfStop := na
    else if close > htfBuy
        htfBreakout := true
        htfActive := false
        htfBuy := na

plot(showHTF and htfActive ? htfBuy : na, "HTF Buy", color=color.orange, style=plot.style_linebr, linewidth=1)
plotshape(showHTF and htfBreakout, "HTF Break", shape.triangleup, location.belowbar, color.orange, size=size.small, text="HTF")

// ═══════════════════════════════════════════════════════════════
// 5. VCP（保持原樣）
// ═══════════════════════════════════════════════════════════════
var int[] vcpPivIdx = array.new_int()
var float[] vcpPivPrice = array.new_float()
var bool[] vcpPivIsHigh = array.new_bool()

vcp_ph = ta.pivothigh(high, vcp_left, vcp_right)
vcp_pl = ta.pivotlow(low, vcp_left, vcp_right)

if not na(vcp_ph)
    array.push(vcpPivIdx, bar_index - vcp_right)
    array.push(vcpPivPrice, vcp_ph)
    array.push(vcpPivIsHigh, true)

if not na(vcp_pl)
    array.push(vcpPivIdx, bar_index - vcp_right)
    array.push(vcpPivPrice, vcp_pl)
    array.push(vcpPivIsHigh, false)

if array.size(vcpPivIdx) > 50
    array.shift(vcpPivIdx)
    array.shift(vcpPivPrice)
    array.shift(vcpPivIsHigh)

f_checkVCP(legs) =>
    bool isValid = false
    float pivotPrice = na
    int sz = array.size(vcpPivIdx)
    if sz >= 2 * legs + 1
        int start = sz - (2 * legs + 1)
        bool structOk = true
        for i = 0 to 2 * legs
            bool isH = array.get(vcpPivIsHigh, start + i)
            if (i % 2 == 0 and not isH) or (i % 2 == 1 and isH)
                structOk := false
        
        if structOk
            bool depthOk = true
            float prevDepth = 100.0
            
            for leg = 0 to legs - 1
                float hA = array.get(vcpPivPrice, start + 2*leg)
                float lB = array.get(vcpPivPrice, start + 2*leg + 1)
                float depth = (hA - lB) / hA * 100.0
                
                if depth < vcpMinDepth or depth > prevDepth
                    depthOk := false
                prevDepth := depth
            
            float lastHigh = array.get(vcpPivPrice, start + 2*legs)
            
            if depthOk and trendUp
                isValid := true
                pivotPrice := lastHigh
    [isValid, pivotPrice]

var bool vcpActive = false
var float vcpBuy = na
var bool vcpBreakout = false
vcpBreakout := false

bool vFound = false
float vPrice = na
if showVCP and not vcpActive
    for legs = 2 to 4
        [ok, p] = f_checkVCP(legs)
        if ok
            vFound := true
            vPrice := p

if vFound and not vcpActive
    vcpActive := true
    vcpBuy := vPrice
    label.new(bar_index, high, "VCP", style=label.style_label_down, color=color.green, textcolor=color.white, size=size.small)

if vcpActive
    if close < ema50 
        vcpActive := false
        vcpBuy := na
    else if close > vcpBuy
        vcpBreakout := true
        vcpActive := false
        vcpBuy := na

plot(showVCP and vcpActive ? vcpBuy : na, "VCP Buy", color=color.green, style=plot.style_linebr, linewidth=1)
plotshape(showVCP and vcpBreakout, "VCP Break", shape.triangleup, location.belowbar, color.lime, size=size.small, text="VCP")

// ═══════════════════════════════════════════════════════════════
// 輔助線
// ═══════════════════════════════════════════════════════════════
plot(ema50, "EMA 50", color.yellow)
plot(ema150, "EMA 150", color.orange)
plot(ema200, "EMA 200", color.red)
